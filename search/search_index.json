{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Project Overview","text":"<p>Networks are often used to simulate important real-world phenomena such as infectious diseases, social influence, and the spread of misinformation.</p> <p>Although real-world network datasets are readily available, simulating diffusion based models on them may be computationally unfeassible due to the large of the networks in them. In this project, we examine how different graph reduction techniques perform when the at downscaling large graphs while preserving properties that are relevant for diffusion. More specifically, we study the performance of graph sparsification and coarsening techniques. </p> <p>In addition to calculating the relevant network metrics of a newly obtain dataset, our workflow   simulates the SIR model on it and calculates a set of commonly used quantities of interested that can be used to further assess the quality of the reduced dataset.</p>"},{"location":"#project-structure","title":"Project Structure","text":"<p>The two main components of this project are:</p> <ol> <li>The minigraphs python library containing the implementation of various GRTs used in the workflow.</li> <li>The workflow that will take a network dataset, reduce it, and the corresponding graph metrics and quantities of interest from the SIR model.</li> </ol> <p>The minigraphs library and workflow can be found in the <code>src</code> and <code>workflows</code> directory, respectively, according to the following structure:</p> <pre><code>src/\n    minigraphs/\nworkflows/\n    config/\n    data/\n    envs/\n    notebooks/\n    scripts/\n    slurm/\n</code></pre>"},{"location":"#workflow-description","title":"Workflow Description","text":"<p>The workflow allows for the generation of reduced network datasets according to different graph reduction techniques.</p> <p>The configuration file <code>workflows/config/config.yaml</code> allows the user to specify the parameters for each reduction technique as well as the simulation parameters for the SIR model. Many GRTs are based on randomized algorithms, so an ensemble of graphs for a set of parameters may be necessary to obtain reasonable confidence intervals on the algorithms performance. The total number of graphs generated for each technique can also be specified in this configuration file.</p> <p>The following DFD highlights the major tasks executed by the workflow for each graph reduction generated:</p> <pre><code>---\ntitle: Network Reduction Process\n---\n\nflowchart TB\n    config[Configuration File]-- \"Network Dataset\" ---&gt; reduce((Reduce Network))\n    config-- \"Reduction Parameters\" ---&gt; reduce\n\n\n    reduce-- \"Network Reduction\" ---&gt; distributions((Calculate Distributions))\n    distributions-- \"Degree Distribution\" ---&gt; characterization((Calculate Network Metrics))\n    distributions-- \"Distance Distributions\" ---&gt; characterization\n\n    reduce-- \"Network Reduction\" ---&gt; simulate((Simulate Model))\n    config-- \"Simulation Parameters\" ---&gt; simulate\n    simulate-- \"Simulation Results\" ---&gt; qois((Calculate Model's Quantities of Interest))\n\n    characterization-- \"Network Metrics\" ---&gt; storage@{shape: cyl, label: \"Reduction Directory\"}\n    qois-- \"QOIs\" ---&gt; storage\n\n    subgraph reduction [Reduction]\n        reduce\n        distributions\n        characterization\n    end\n\n    subgraph simulation [Simulation]\n        simulate\n        qois\n    end</code></pre>"},{"location":"#workflow-execution","title":"Workflow Execution","text":"<p>Various pre-defined conda environments are provided in the <code>workflows/envs</code> directory. The current version of the workflow can be executed in its entirety with the environment defined by <code>env.yaml</code> within this directory.</p> <p>The <code>all</code> rule defined in the <code>Snakefile</code> will calculate the following for each graph reduction of the <code>hamsterster/giant</code> dataset:</p> <ul> <li>Graph Adjacency Matrix</li> <li>Dataset Network Metrics</li> <li>Network Property Distribution Metrics</li> <li>Sir Quantities of Interest</li> </ul>"},{"location":"reference/inspection/","title":"minigraphs.inspection","text":""},{"location":"reference/inspection/#minigraphs.inspection","title":"<code>minigraphs.inspection</code>","text":""},{"location":"reference/inspection/#minigraphs.inspection-functions","title":"Functions","text":""},{"location":"reference/inspection/#minigraphs.inspection.draw_subgraph","title":"<code>draw_subgraph(graph, subgraph, pos, *, graph_kwargs=None, subgraph_kwargs=None, ax=None)</code>","text":"<p>Draws a graph and highlights the nodes corresponding to the specified subgraph.</p> <p>Parameters:</p> <ul> <li> <code>graph</code>               (<code>Graph</code>)           \u2013            <p>The original graph</p> </li> <li> <code>subgraph</code>               (<code>Union[Graph, List[int]]</code>)           \u2013            <p>The subgraph or set of nodes the finde the subgraph.</p> </li> <li> <code>pos</code>               (<code>Dict[int, Tuple[float, float]]</code>)           \u2013            <p>A dictionary with the node positions</p> </li> </ul> Source code in <code>src/minigraphs/inspection/drawing.py</code> <pre><code>@get_context\ndef draw_subgraph(\n    graph: Graph, \n    subgraph: Union[Graph, List[int]], \n    pos: Dict[int, Tuple[float,float]],\n    * , \n    graph_kwargs: Optional[Dict[str, Any]]=None, \n    subgraph_kwargs: Optional[Dict[str, Any]]=None, \n    ax: Optional[Axes]=None\n):\n    \"\"\"Draws a graph and highlights the nodes corresponding to the specified subgraph.\n\n    Parameters\n    ----------\n    graph : Graph\n        The original graph\n    subgraph : Union[Graph, List[int]]\n        The subgraph or set of nodes the finde the subgraph.\n    pos : Dict[int, Tuple[float, float]]\n        A dictionary with the node positions\n    \"\"\"\n    # Retrieve nodelist\n    nodelist = list(subgraph.nodes()) if isinstance(subgraph, Graph) else subgraph\n    graph_kwargs = graph_kwargs if graph_kwargs is not None else {}\n    subgraph_kwargs = subgraph_kwargs if subgraph_kwargs is not None else {}\n\n    first_color = graph_kwargs.get('node_color')\n    second_color = subgraph_kwargs.get('node_color')\n\n    graph_kwargs['node_color'] = first_color if first_color is not None else 'tab:blue'\n    subgraph_kwargs['node_color'] = second_color if second_color is not None else 'tab:orange'\n\n    nx.draw_networkx_nodes(graph, pos, ax=ax, **graph_kwargs)\n    nx.draw_networkx_nodes(graph, pos, nodelist=nodelist, ax=ax, **subgraph_kwargs)\n    nx.draw_networkx_edges(graph, pos, ax=ax)\n\n    return ax\n</code></pre>"},{"location":"reference/mcmc/","title":"minigraphs.mcmc","text":""},{"location":"reference/mcmc/#minigraphs.mcmc.annealer.SimulatedAnnealing","title":"<code>minigraphs.mcmc.annealer.SimulatedAnnealing</code>","text":"<p>Generic simulated\u2011annealing / MCMC driver on top of a <code>Chain</code>.</p> <p>Parameters:</p> <ul> <li> <code>chain</code>               (<code>Chain</code>)           \u2013            <p>Instance that supplies proposals via <code>chain.propose()</code>.</p> </li> <li> <code>energy</code>               (<code>Callable[[Graph], float]</code>)           \u2013            <p>Function that returns energy (lower is better) of a graph.</p> </li> <li> <code>schedule</code>               (<code>Union[float, Callable[[int], float]]</code>)           \u2013            <p>Inverse temperature of the annealer at every iteration of the process (schedule).</p> </li> <li> <code>n_steps</code>               (<code>int</code>, default:                   <code>10_000</code> )           \u2013            <p>Total number of proposal steps.</p> </li> <li> <code>seed</code>               (<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>Random state for the annealer.</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to display a progress bar.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>best_energy_</code>               (<code>float</code>)           \u2013            <p>Lowest energy encountered along the process.</p> </li> <li> <code>best_graph_</code>               (<code>Graph</code>)           \u2013            <p>Lowest energy graph found along the process.</p> </li> <li> <code>history_</code>               (<code>DataFrame</code>)           \u2013            <p>Pandas Dataframe containing the history of inverse temepratures and energies visited by the annealer.</p> </li> </ul> Source code in <code>src/minigraphs/mcmc/annealer.py</code> <pre><code>class SimulatedAnnealing:\n    \"\"\"Generic simulated\u2011annealing / MCMC driver on top of a ``Chain``.\n\n    Parameters\n    ----------\n    chain : Chain\n        Instance that supplies proposals via ``chain.propose()``.\n    energy : Callable[[nx.Graph], float]\n        Function that returns *energy* (lower is better) of a graph.\n    schedule : Union[float, Callable[[int], float]]\n        Inverse temperature of the annealer at every iteration of the process (schedule).\n    n_steps : int, default 10_000\n        Total number of proposal steps.\n    seed : Optional[int]\n        Random state for the annealer.\n    verbose : bool, default=False\n        Whether to display a progress bar.\n\n    Attributes\n    ----------\n    best_energy_ : float\n        Lowest energy encountered along the process.\n    best_graph_ : Graph\n        Lowest energy graph found along the process.\n    history_ : DataFrame\n        Pandas Dataframe containing the history of inverse temepratures and energies visited\n        by the annealer.\n    \"\"\"\n    def __init__(\n        self,\n        chain: Chain,\n        energy: Callable[[Graph], float],\n        schedule: Union[float, Callable[[int], float]],\n        n_steps: int = 1_000,\n        *,\n        seed: Optional[int] = None,\n        verbose: Optional[bool]= False,\n\n    ) -&gt; None:\n        self.chain = chain\n        self.energy_fn = energy\n        self.schedule = schedule \n        self.n_steps = n_steps\n        self.random = random.Random(seed)\n        self.verbose = verbose\n\n    def run(self) -&gt; None:\n        \"\"\"Run the annealing / MCMC loop.\"\"\"\n        #=== CHECKS ===#\n        if self.n_steps &lt;= 0:\n            raise ValueError(\"Error: Number of steps must be greater than 0.\")\n\n        #=== INITIALIZATION ===#\n        self._history_ : List[State] = [None] * self.n_steps\n\n        # Initialize internal state\n        old_graph = self.chain.state \n        old_energy = self.energy_fn(old_graph)\n\n        # Initialize schedule\n        schedule = self.schedule if callable(self.schedule) else lambda _: float(self.schedule)\n\n        # Initialize best graph along with it's energy\n        self.best_graph_ = old_graph\n        self.best_energy_ = old_energy\n\n        for step in tqdm(range(self.n_steps), disable=not self.verbose):\n            beta = schedule(step)\n            self.chain.propose()\n            new_graph = self.chain.state \n            new_energy = self.energy_fn(new_graph)\n\n            # Metropolis acceptance probability\n            dE = new_energy - old_energy\n            accept = dE &lt; 0 or self.random.random() &lt; exp(-beta * dE)\n\n            if accept:\n                # Update internal variables\n                old_graph, old_energy = new_graph, new_energy\n\n                # Update best graph if new energy minimum is achieved\n                if self.best_energy_ &gt; new_energy:\n                    self.best_graph_ = new_graph\n                    self.best_energy_ = new_energy\n            else:\n                self.chain.reject()\n\n            # Store state\n            self._history_[step] = State(\n                beta=beta,\n                energy=old_energy\n            )\n\n    @property\n    def history_(self) -&gt; DataFrame:\n        \"\"\"Retrieves the annealer's state history.\n        \"\"\"\n        return DataFrame(self._history_,)\n</code></pre>"},{"location":"reference/mcmc/#minigraphs.mcmc.annealer.SimulatedAnnealing-attributes","title":"Attributes","text":""},{"location":"reference/mcmc/#minigraphs.mcmc.annealer.SimulatedAnnealing.history_","title":"<code>history_</code>  <code>property</code>","text":"<p>Retrieves the annealer's state history.</p>"},{"location":"reference/mcmc/#minigraphs.mcmc.annealer.SimulatedAnnealing-functions","title":"Functions","text":""},{"location":"reference/mcmc/#minigraphs.mcmc.annealer.SimulatedAnnealing.run","title":"<code>run()</code>","text":"<p>Run the annealing / MCMC loop.</p> Source code in <code>src/minigraphs/mcmc/annealer.py</code> <pre><code>def run(self) -&gt; None:\n    \"\"\"Run the annealing / MCMC loop.\"\"\"\n    #=== CHECKS ===#\n    if self.n_steps &lt;= 0:\n        raise ValueError(\"Error: Number of steps must be greater than 0.\")\n\n    #=== INITIALIZATION ===#\n    self._history_ : List[State] = [None] * self.n_steps\n\n    # Initialize internal state\n    old_graph = self.chain.state \n    old_energy = self.energy_fn(old_graph)\n\n    # Initialize schedule\n    schedule = self.schedule if callable(self.schedule) else lambda _: float(self.schedule)\n\n    # Initialize best graph along with it's energy\n    self.best_graph_ = old_graph\n    self.best_energy_ = old_energy\n\n    for step in tqdm(range(self.n_steps), disable=not self.verbose):\n        beta = schedule(step)\n        self.chain.propose()\n        new_graph = self.chain.state \n        new_energy = self.energy_fn(new_graph)\n\n        # Metropolis acceptance probability\n        dE = new_energy - old_energy\n        accept = dE &lt; 0 or self.random.random() &lt; exp(-beta * dE)\n\n        if accept:\n            # Update internal variables\n            old_graph, old_energy = new_graph, new_energy\n\n            # Update best graph if new energy minimum is achieved\n            if self.best_energy_ &gt; new_energy:\n                self.best_graph_ = new_graph\n                self.best_energy_ = new_energy\n        else:\n            self.chain.reject()\n\n        # Store state\n        self._history_[step] = State(\n            beta=beta,\n            energy=old_energy\n        )\n</code></pre>"},{"location":"reference/mcmc/#minigraphs.mcmc.parallel_tempering.ParallelTempering","title":"<code>minigraphs.mcmc.parallel_tempering.ParallelTempering</code>","text":"Source code in <code>src/minigraphs/mcmc/parallel_tempering.py</code> <pre><code>class ParallelTempering:\n    def __init__(\n            self,\n            comm: Comm,\n            annealer_data: List[Tuple[Chain, float]],\n            energy: Callable[[Graph], float],\n            exchange_freq: int, \n            n_steps: int,\n            *, \n            verbose: Optional[bool]=False,\n    ):\n        \"\"\"Implementation of the Parallel Tempering algorithm on graphs.\n\n        Various replicas (instances of the `SimulatedAnnealing`) class are instantiated and allowed to optimize\n        the graph structure. These replicas will exchange inverse temperatures every `exchange_freq` steps.\n\n        Parameters\n        ----------\n        comm : Comm \n            MPI group coordinating each rank.\n        annealer_data : List[Tuple[Chain, float]]\n            List of tuples containing the chain to be used by each replica, along with their corresponding inverse temperatures.\n        energy : Callable[[Graph], float]\n            Function that calculates the energy of a graph.\n        exchange_freq : int\n            Number of steps between exchanges.\n        n_steps:\n            Total number of steps to run the algorithm.\n        self.verbose:\n            Whether to display a progress bar.\n        \"\"\"\n        self.comm = comm\n        self.rank = self.comm.Get_rank()\n        self.size = self.comm.Get_size()\n\n        self.annealer_data = annealer_data\n        self.energy = energy\n        self.exchange_freq = exchange_freq\n        self.n_steps = n_steps\n        self.verbose = verbose\n\n    def _exchange(self, partner: int, my_inv_temp: float) -&gt; float:\n        \"\"\"Proposes swap to partner by sending them current energy and inv temp.\n\n        Replicas send their inverse temperature if the rank of their partner is higher (`partner &gt; self.rank`)\n        and receive otherwise:\n            - Receiver (higher rank) decides whether to swap.\n            - Sender (lower rank) adopts the returned inverse temperature unconditionally.\n\n        Parameters\n        ----------\n        partner : int\n            Partner to exchange inverse temperatures with.\n        my_inv_temp : float \n            Current inverse temperature ofo the replica.\n\n        Returns\n        -------\n        float\n            The new inverse temperature to use.\n        \"\"\"\n        my_energy = self.annealer._history_[-1].energy\n\n        # Send information\n        if (partner == (self.rank+1)) and (partner &lt; self.size):\n            # Send energy and inverse temperature for evaluation\n            self.comm.send(\n                (my_energy, my_inv_temp),\n                dest=partner, \n            )\n\n            # Receive new inverse temperature from partner\n            my_inv_temp = self.comm.recv(\n                source=partner,\n            )\n\n\n        # Receive information from partner\n        elif (partner == (self.rank-1) and (partner &gt;= 0)):\n            partner_energy, partner_inv_temp = self.comm.recv(\n                source=partner,\n            )\n\n            dB = partner_inv_temp - my_inv_temp\n            dE = partner_energy - my_energy\n            exponent = dB * dE\n\n            # Accept or reject inv temperature swap\n            accept = exponent &lt; 0 or random.random() &lt; exp(-exponent)\n            if accept:\n                my_inv_temp, partner_inv_temp = partner_inv_temp, my_inv_temp\n\n            # Send inverse temperature back to partner\n            self.comm.send(\n                partner_inv_temp,\n                dest=partner,\n            )\n\n        return my_inv_temp\n\n    def run(self):\n        \"\"\"Runs the parallel tempering algorithm.\n        \"\"\"\n        # Initialize properties of the annealer.\n        if len(self.annealer_data) != self.size:\n            raise ValueError(f\"Mismatch between annealer data ({len(self.annealer_data)}) and comm size ({self.size})\")\n\n        sorted_data = sorted(self.annealer_data, key=lambda item: item[1])\n        chain, beta = sorted_data[self.rank]\n\n        # Initialize annealer\n        self.annealer = SimulatedAnnealing(\n            chain,\n            self.energy,\n            beta\n        )\n\n        # Estimate number of episodes\n        n_episodes = ceil(self.n_steps / self.exchange_freq)\n        n_steps_remain = self.n_steps\n\n        # Allocate memory for history\n        self._history_ : List[pd.DataFrame] = [None] * n_episodes\n\n        for episode in tqdm(range(n_episodes)):\n            # Number of steps in the current episode\n            remainder = n_steps_remain % self.exchange_freq\n            n_steps = self.exchange_freq if remainder == 0 else remainder\n\n            # Run annealer\n            self.annealer.n_steps = n_steps\n            self.annealer.run()\n            n_steps_remain -= n_steps\n\n            # Append history\n            self._history_[episode] = self.annealer.history_\n\n            # Even ranks initiate exchange\n            partner = self.rank + 1 if (self.rank % 2 == 0) else self.rank - 1\n            beta = self._exchange(partner, beta)\n\n            # Odd ranks initiate exchange\n            partner = self.rank + 1 if (self.rank % 2 == 1) else self.rank - 1\n            beta = self._exchange(partner, beta)\n\n            self.annealer.schedule = beta\n\n        self.comm.Barrier()        \n\n    @property\n    def history_(self) -&gt; pd.DataFrame:\n        \"\"\"History of the replica.\n        \"\"\"\n        return pd.concat(self._history_)\n\n    def gather_results(self):\n        \"\"\"\n        Gathers the histories from all replicas and stores them into a `pd.Series` object.\n        \"\"\"\n        if (self.rank == 0) and self.verbose:\n            print(\"Collecting histories...\")\n\n        histories = self.comm.gather(\n            self.history_.to_dict('list'), \n            root=0\n        )\n\n        if self.rank == 0:\n            self._results = pd.concat(\n                (pd.DataFrame(history) for history in histories),\n                keys=range(len(histories)),\n                names=['replica','step']\n            )\n\n    @wraps(pd.DataFrame.to_csv)\n    def results_to_csv(self, *args, **kwargs) -&gt; None:\n        \"\"\"Saves the trajectories of each replica to a csv file.\n        \"\"\"\n        if self.rank == 0:\n            self._results.to_csv(*args, **kwargs)\n\n    def best_graph_save(self, function: Callable[[Graph], None], **kwargs: Dict[str, Any]) -&gt; None:\n        \"\"\"Saves the best graph found along the process using the specified function.\n\n        Parameters\n        ----------\n        function : Callable[[Graph], None]\n            Function that will be used to save the graph.\n\n        kwargs : Dict[str, Any]\n            Dictionary of arguments passed to the saving function.\n        \"\"\"\n        dtype = [('energy', np.float64), ('rank', np.int32)]\n        sendbuf = np.array((self.annealer.best_energy_, self.rank), dtype=dtype)\n        recvbuf = np.array((0.0, -1), dtype=dtype)\n\n        self.comm.Allreduce(\n            [sendbuf, 1, DOUBLE_INT],\n            [recvbuf, 1, DOUBLE_INT],\n            op=MINLOC\n        )\n\n        if self.rank == recvbuf['rank']:\n            print(f\"Rank {self.rank}: saving best graph...\")\n            function(self.annealer.best_graph_, **kwargs)\n</code></pre>"},{"location":"reference/mcmc/#minigraphs.mcmc.parallel_tempering.ParallelTempering-attributes","title":"Attributes","text":""},{"location":"reference/mcmc/#minigraphs.mcmc.parallel_tempering.ParallelTempering.history_","title":"<code>history_</code>  <code>property</code>","text":"<p>History of the replica.</p>"},{"location":"reference/mcmc/#minigraphs.mcmc.parallel_tempering.ParallelTempering-functions","title":"Functions","text":""},{"location":"reference/mcmc/#minigraphs.mcmc.parallel_tempering.ParallelTempering.__init__","title":"<code>__init__(comm, annealer_data, energy, exchange_freq, n_steps, *, verbose=False)</code>","text":"<p>Implementation of the Parallel Tempering algorithm on graphs.</p> <p>Various replicas (instances of the <code>SimulatedAnnealing</code>) class are instantiated and allowed to optimize the graph structure. These replicas will exchange inverse temperatures every <code>exchange_freq</code> steps.</p> <p>Parameters:</p> <ul> <li> <code>comm</code>               (<code>Comm</code>)           \u2013            <p>MPI group coordinating each rank.</p> </li> <li> <code>annealer_data</code>               (<code>List[Tuple[Chain, float]]</code>)           \u2013            <p>List of tuples containing the chain to be used by each replica, along with their corresponding inverse temperatures.</p> </li> <li> <code>energy</code>               (<code>Callable[[Graph], float]</code>)           \u2013            <p>Function that calculates the energy of a graph.</p> </li> <li> <code>exchange_freq</code>               (<code>int</code>)           \u2013            <p>Number of steps between exchanges.</p> </li> <li> <code>n_steps</code>               (<code>int</code>)           \u2013            <p>Total number of steps to run the algorithm.</p> </li> <li> <code>self</code>           \u2013            <p>Whether to display a progress bar.</p> </li> </ul> Source code in <code>src/minigraphs/mcmc/parallel_tempering.py</code> <pre><code>def __init__(\n        self,\n        comm: Comm,\n        annealer_data: List[Tuple[Chain, float]],\n        energy: Callable[[Graph], float],\n        exchange_freq: int, \n        n_steps: int,\n        *, \n        verbose: Optional[bool]=False,\n):\n    \"\"\"Implementation of the Parallel Tempering algorithm on graphs.\n\n    Various replicas (instances of the `SimulatedAnnealing`) class are instantiated and allowed to optimize\n    the graph structure. These replicas will exchange inverse temperatures every `exchange_freq` steps.\n\n    Parameters\n    ----------\n    comm : Comm \n        MPI group coordinating each rank.\n    annealer_data : List[Tuple[Chain, float]]\n        List of tuples containing the chain to be used by each replica, along with their corresponding inverse temperatures.\n    energy : Callable[[Graph], float]\n        Function that calculates the energy of a graph.\n    exchange_freq : int\n        Number of steps between exchanges.\n    n_steps:\n        Total number of steps to run the algorithm.\n    self.verbose:\n        Whether to display a progress bar.\n    \"\"\"\n    self.comm = comm\n    self.rank = self.comm.Get_rank()\n    self.size = self.comm.Get_size()\n\n    self.annealer_data = annealer_data\n    self.energy = energy\n    self.exchange_freq = exchange_freq\n    self.n_steps = n_steps\n    self.verbose = verbose\n</code></pre>"},{"location":"reference/mcmc/#minigraphs.mcmc.parallel_tempering.ParallelTempering.best_graph_save","title":"<code>best_graph_save(function, **kwargs)</code>","text":"<p>Saves the best graph found along the process using the specified function.</p> <p>Parameters:</p> <ul> <li> <code>function</code>               (<code>Callable[[Graph], None]</code>)           \u2013            <p>Function that will be used to save the graph.</p> </li> <li> <code>kwargs</code>               (<code>Dict[str, Any]</code>, default:                   <code>{}</code> )           \u2013            <p>Dictionary of arguments passed to the saving function.</p> </li> </ul> Source code in <code>src/minigraphs/mcmc/parallel_tempering.py</code> <pre><code>def best_graph_save(self, function: Callable[[Graph], None], **kwargs: Dict[str, Any]) -&gt; None:\n    \"\"\"Saves the best graph found along the process using the specified function.\n\n    Parameters\n    ----------\n    function : Callable[[Graph], None]\n        Function that will be used to save the graph.\n\n    kwargs : Dict[str, Any]\n        Dictionary of arguments passed to the saving function.\n    \"\"\"\n    dtype = [('energy', np.float64), ('rank', np.int32)]\n    sendbuf = np.array((self.annealer.best_energy_, self.rank), dtype=dtype)\n    recvbuf = np.array((0.0, -1), dtype=dtype)\n\n    self.comm.Allreduce(\n        [sendbuf, 1, DOUBLE_INT],\n        [recvbuf, 1, DOUBLE_INT],\n        op=MINLOC\n    )\n\n    if self.rank == recvbuf['rank']:\n        print(f\"Rank {self.rank}: saving best graph...\")\n        function(self.annealer.best_graph_, **kwargs)\n</code></pre>"},{"location":"reference/mcmc/#minigraphs.mcmc.parallel_tempering.ParallelTempering.gather_results","title":"<code>gather_results()</code>","text":"<p>Gathers the histories from all replicas and stores them into a <code>pd.Series</code> object.</p> Source code in <code>src/minigraphs/mcmc/parallel_tempering.py</code> <pre><code>def gather_results(self):\n    \"\"\"\n    Gathers the histories from all replicas and stores them into a `pd.Series` object.\n    \"\"\"\n    if (self.rank == 0) and self.verbose:\n        print(\"Collecting histories...\")\n\n    histories = self.comm.gather(\n        self.history_.to_dict('list'), \n        root=0\n    )\n\n    if self.rank == 0:\n        self._results = pd.concat(\n            (pd.DataFrame(history) for history in histories),\n            keys=range(len(histories)),\n            names=['replica','step']\n        )\n</code></pre>"},{"location":"reference/mcmc/#minigraphs.mcmc.parallel_tempering.ParallelTempering.results_to_csv","title":"<code>results_to_csv(*args, **kwargs)</code>","text":"<p>Saves the trajectories of each replica to a csv file.</p> Source code in <code>src/minigraphs/mcmc/parallel_tempering.py</code> <pre><code>@wraps(pd.DataFrame.to_csv)\ndef results_to_csv(self, *args, **kwargs) -&gt; None:\n    \"\"\"Saves the trajectories of each replica to a csv file.\n    \"\"\"\n    if self.rank == 0:\n        self._results.to_csv(*args, **kwargs)\n</code></pre>"},{"location":"reference/mcmc/#minigraphs.mcmc.parallel_tempering.ParallelTempering.run","title":"<code>run()</code>","text":"<p>Runs the parallel tempering algorithm.</p> Source code in <code>src/minigraphs/mcmc/parallel_tempering.py</code> <pre><code>def run(self):\n    \"\"\"Runs the parallel tempering algorithm.\n    \"\"\"\n    # Initialize properties of the annealer.\n    if len(self.annealer_data) != self.size:\n        raise ValueError(f\"Mismatch between annealer data ({len(self.annealer_data)}) and comm size ({self.size})\")\n\n    sorted_data = sorted(self.annealer_data, key=lambda item: item[1])\n    chain, beta = sorted_data[self.rank]\n\n    # Initialize annealer\n    self.annealer = SimulatedAnnealing(\n        chain,\n        self.energy,\n        beta\n    )\n\n    # Estimate number of episodes\n    n_episodes = ceil(self.n_steps / self.exchange_freq)\n    n_steps_remain = self.n_steps\n\n    # Allocate memory for history\n    self._history_ : List[pd.DataFrame] = [None] * n_episodes\n\n    for episode in tqdm(range(n_episodes)):\n        # Number of steps in the current episode\n        remainder = n_steps_remain % self.exchange_freq\n        n_steps = self.exchange_freq if remainder == 0 else remainder\n\n        # Run annealer\n        self.annealer.n_steps = n_steps\n        self.annealer.run()\n        n_steps_remain -= n_steps\n\n        # Append history\n        self._history_[episode] = self.annealer.history_\n\n        # Even ranks initiate exchange\n        partner = self.rank + 1 if (self.rank % 2 == 0) else self.rank - 1\n        beta = self._exchange(partner, beta)\n\n        # Odd ranks initiate exchange\n        partner = self.rank + 1 if (self.rank % 2 == 1) else self.rank - 1\n        beta = self._exchange(partner, beta)\n\n        self.annealer.schedule = beta\n\n    self.comm.Barrier()        \n</code></pre>"},{"location":"reference/mcmc/#chains","title":"Chains","text":""},{"location":"reference/mcmc/#minigraphs.mcmc.chains","title":"<code>minigraphs.mcmc.chains</code>","text":""},{"location":"reference/mcmc/#minigraphs.mcmc.chains-classes","title":"Classes","text":""},{"location":"reference/mcmc/#minigraphs.mcmc.chains.Chain","title":"<code>Chain</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for graph\u2011valued Markov chains.</p> <p>Parameters:</p> <ul> <li> <code>seed</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>Random state of the chain.</p> </li> </ul> Source code in <code>src/minigraphs/mcmc/chains.py</code> <pre><code>class Chain(ABC):\n    \"\"\"Base class for graph\u2011valued Markov chains.\n\n    Parameters\n    ----------\n    seed : int\n        Random state of the chain.\n    \"\"\"\n\n    def __init__(\n        self,\n        seed: int=None,\n    ) -&gt; None:\n        self.random = random.Random(seed)\n\n    @abstractmethod\n    def propose(self):\n        \"\"\"Proposes a new graph and updates its internal state.\n        \"\"\"\n        pass \n\n    @abstractmethod\n    def reject(self):\n        \"\"\"Rejects the graph proposal and retrieves the previous internal state.\n        \"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def state(self) -&gt; nx.Graph:\n        \"\"\"Retrieves the current state of the chain.\n        \"\"\"\n\n    def __iter__(self):\n        return self \n\n    def __next__(self):\n        \"\"\"Propse new graph and update internal state.\n        \"\"\"\n        state = self.state \n        self.propose()\n        return state\n</code></pre>"},{"location":"reference/mcmc/#minigraphs.mcmc.chains.Chain-attributes","title":"Attributes","text":""},{"location":"reference/mcmc/#minigraphs.mcmc.chains.Chain.state","title":"<code>state</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Retrieves the current state of the chain.</p>"},{"location":"reference/mcmc/#minigraphs.mcmc.chains.Chain-functions","title":"Functions","text":""},{"location":"reference/mcmc/#minigraphs.mcmc.chains.Chain.__next__","title":"<code>__next__()</code>","text":"<p>Propse new graph and update internal state.</p> Source code in <code>src/minigraphs/mcmc/chains.py</code> <pre><code>def __next__(self):\n    \"\"\"Propse new graph and update internal state.\n    \"\"\"\n    state = self.state \n    self.propose()\n    return state\n</code></pre>"},{"location":"reference/mcmc/#minigraphs.mcmc.chains.Chain.propose","title":"<code>propose()</code>  <code>abstractmethod</code>","text":"<p>Proposes a new graph and updates its internal state.</p> Source code in <code>src/minigraphs/mcmc/chains.py</code> <pre><code>@abstractmethod\ndef propose(self):\n    \"\"\"Proposes a new graph and updates its internal state.\n    \"\"\"\n    pass \n</code></pre>"},{"location":"reference/mcmc/#minigraphs.mcmc.chains.Chain.reject","title":"<code>reject()</code>  <code>abstractmethod</code>","text":"<p>Rejects the graph proposal and retrieves the previous internal state.</p> Source code in <code>src/minigraphs/mcmc/chains.py</code> <pre><code>@abstractmethod\ndef reject(self):\n    \"\"\"Rejects the graph proposal and retrieves the previous internal state.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/mcmc/#minigraphs.mcmc.chains.CoarseningChain","title":"<code>CoarseningChain</code>","text":"<p>               Bases: <code>Chain</code></p> <p>A graph chain implementing node coarsening.</p> Source code in <code>src/minigraphs/mcmc/chains.py</code> <pre><code>class CoarseningChain(Chain):\n    \"\"\"A graph chain implementing node coarsening.\n    \"\"\"\n\n    def __init__(self, graph: nx.Graph, n_groups: int, seed: int=None):\n        super().__init__(seed=seed)\n        self.graph = graph \n        self.n_groups = n_groups\n        self.groups = range(n_groups)\n\n        # Generate coarsened graph.\n        # Nodes hold references to sets containing the nodes encapsulated by the super nodes\n        # Edges contain scalars reflecting the number of edges a super edge represents\n        self.graph_coarse: nx.Graph = nx.complete_graph(self.n_groups)\n        nx.set_node_attributes(self.graph_coarse, values = {node: {'nodes': RandomizedSet(self.random)} for node in self.graph_coarse.nodes()})\n        nx.set_edge_attributes(self.graph_coarse, name='count', values=0)\n\n        # Randomly allocate nodes to super nodes\n        for node in self.graph.nodes():\n            # Select a group at random\n            group = self.random.choice(self.groups)\n\n            # Store references\n            self.graph.nodes[node]['group'] = group \n            self.graph_coarse.nodes[group]['nodes'].insert(node)\n\n        # Identify edges of coarsened graph\n        for edge in self.graph.edges():\n            # Identify corresponding super edge\n            super_edge = tuple((self.graph.nodes[node]['group'] for node in edge))\n\n            if super_edge[0] != super_edge[1]:\n                self.graph_coarse.edges[super_edge]['count'] += 1\n\n    @property \n    def state(self) -&gt; nx.Graph:\n        \"\"\"Returns the coarsened graph.\n        \"\"\"\n        graph = nx.empty_graph(self.n_groups)\n        graph.add_edges_from(((u,v) for (u,v,data) in self.graph_coarse.edges(data=True) if data['count'] &gt; 0))\n\n        return graph\n\n    def propose(self) -&gt; nx.Graph:\n        \"\"\"Proposes a new graph by randomly moving nodes across super nodes.\n\n        Randomly selects a super node to draw a node and moves it to a random different super node,\n        updating the edge counts along the way.\n        \"\"\"\n        # Select random group\n        old_group = self.random.choice(self.groups)\n        nodes: RandomizedSet = self.graph_coarse.nodes[old_group]['nodes']\n\n        if nodes: # Check for nodes in group\n            # Select random node\n            node = nodes.getRandom()\n            neighbors = list(self.graph.neighbors(node))\n\n            if neighbors: # Check for neighbors\n                # Select random neighbor\n                neighbor = self.random.choice(neighbors)\n                new_group = self.graph.nodes[neighbor]['group']\n\n                if old_group != new_group:\n                    # Update data.\n                    self.change = (node, old_group)\n                    self._move_node(node, new_group)\n\n    def _move_node(self, node: int, new_group: int):\n        \"\"\"Moves a node to a new group.\n        \"\"\"\n        old_group = self.graph.nodes[node]['group']\n\n        # Update node data\n        self.graph.nodes[node]['group'] = new_group\n        self.graph_coarse.nodes[old_group]['nodes'].remove(node)\n        self.graph_coarse.nodes[new_group]['nodes'].insert(node)\n\n        # Update edge counts\n        for neighbor in list(self.graph.neighbors(node)):\n            neighbor_group = self.graph.nodes[neighbor]['group']\n\n            # Update edge counts\n            if old_group != neighbor_group:\n                old_edge = (old_group, neighbor_group)\n                self.graph_coarse.edges[old_edge]['count'] -= 1 \n\n            if new_group != neighbor_group:\n                new_edge = (new_group, neighbor_group)\n                self.graph_coarse.edges[new_edge]['count'] += 1\n\n    def reject(self):\n        \"\"\"Reject the proposed change and reverse the proposed merge.\n        \"\"\"\n        # Update node data\n        node, old_group = self.change\n        self._move_node(node, old_group)\n</code></pre>"},{"location":"reference/mcmc/#minigraphs.mcmc.chains.CoarseningChain-attributes","title":"Attributes","text":""},{"location":"reference/mcmc/#minigraphs.mcmc.chains.CoarseningChain.state","title":"<code>state</code>  <code>property</code>","text":"<p>Returns the coarsened graph.</p>"},{"location":"reference/mcmc/#minigraphs.mcmc.chains.CoarseningChain-functions","title":"Functions","text":""},{"location":"reference/mcmc/#minigraphs.mcmc.chains.CoarseningChain.propose","title":"<code>propose()</code>","text":"<p>Proposes a new graph by randomly moving nodes across super nodes.</p> <p>Randomly selects a super node to draw a node and moves it to a random different super node, updating the edge counts along the way.</p> Source code in <code>src/minigraphs/mcmc/chains.py</code> <pre><code>def propose(self) -&gt; nx.Graph:\n    \"\"\"Proposes a new graph by randomly moving nodes across super nodes.\n\n    Randomly selects a super node to draw a node and moves it to a random different super node,\n    updating the edge counts along the way.\n    \"\"\"\n    # Select random group\n    old_group = self.random.choice(self.groups)\n    nodes: RandomizedSet = self.graph_coarse.nodes[old_group]['nodes']\n\n    if nodes: # Check for nodes in group\n        # Select random node\n        node = nodes.getRandom()\n        neighbors = list(self.graph.neighbors(node))\n\n        if neighbors: # Check for neighbors\n            # Select random neighbor\n            neighbor = self.random.choice(neighbors)\n            new_group = self.graph.nodes[neighbor]['group']\n\n            if old_group != new_group:\n                # Update data.\n                self.change = (node, old_group)\n                self._move_node(node, new_group)\n</code></pre>"},{"location":"reference/mcmc/#minigraphs.mcmc.chains.CoarseningChain.reject","title":"<code>reject()</code>","text":"<p>Reject the proposed change and reverse the proposed merge.</p> Source code in <code>src/minigraphs/mcmc/chains.py</code> <pre><code>def reject(self):\n    \"\"\"Reject the proposed change and reverse the proposed merge.\n    \"\"\"\n    # Update node data\n    node, old_group = self.change\n    self._move_node(node, old_group)\n</code></pre>"},{"location":"reference/mcmc/#minigraphs.mcmc.chains.SubgraphBoundary","title":"<code>SubgraphBoundary</code>","text":"<p>               Bases: <code>Chain</code></p> <p>Proposes subgraphs by replacing <code>n_swaps</code> nodes for nodes on the boundary with the subgraph.</p> Source code in <code>src/minigraphs/mcmc/chains.py</code> <pre><code>class SubgraphBoundary(Chain):\n    \"\"\"Proposes subgraphs by replacing `n_swaps` nodes for nodes on the boundary with the subgraph. \n    \"\"\"\n    def __init__(\n            self, \n            graph,\n            n_nodes,\n            n_swaps=1,\n            seed = None\n        ) -&gt; None:\n        super().__init__(seed)\n        self.graph = graph\n        self.n_nodes = n_nodes\n        self.n_swaps = n_swaps\n\n        # Generate subgraph in the largest connected component\n        nodes = list(max(nx.connected_components(graph), key=len))\n\n        if len(nodes) &lt;= n_nodes:\n            raise ValueError(\"Largest connected component is not large enough.\")\n        else:\n            self.subgraph = nx.subgraph(graph, self.random.sample(nodes, k=self.n_nodes))\n\n    def propose(self):\n        \"\"\"Proposes a new graph by swapping nodes from the boundary.\n        \"\"\"\n        self.old_nodes = list(self.subgraph.nodes())\n        nodes_boundary = list(nx.node_boundary(self.graph, self.old_nodes))\n\n        nodes_new = (\n            self.random.sample(self.old_nodes, k=(self.n_nodes - self.n_swaps)) + \n            self.random.sample(nodes_boundary, k=self.n_swaps)\n        )\n\n        self.subgraph = nx.subgraph(self.graph, nodes_new)\n\n    def reject(self):\n        self.subgraph = nx.subgraph(self.graph, self.old_nodes)\n\n    @property \n    def state(self):\n        \"\"\"The currently sampled subgraph\n        \"\"\"\n        return self.subgraph\n</code></pre>"},{"location":"reference/mcmc/#minigraphs.mcmc.chains.SubgraphBoundary-attributes","title":"Attributes","text":""},{"location":"reference/mcmc/#minigraphs.mcmc.chains.SubgraphBoundary.state","title":"<code>state</code>  <code>property</code>","text":"<p>The currently sampled subgraph</p>"},{"location":"reference/mcmc/#minigraphs.mcmc.chains.SubgraphBoundary-functions","title":"Functions","text":""},{"location":"reference/mcmc/#minigraphs.mcmc.chains.SubgraphBoundary.propose","title":"<code>propose()</code>","text":"<p>Proposes a new graph by swapping nodes from the boundary.</p> Source code in <code>src/minigraphs/mcmc/chains.py</code> <pre><code>def propose(self):\n    \"\"\"Proposes a new graph by swapping nodes from the boundary.\n    \"\"\"\n    self.old_nodes = list(self.subgraph.nodes())\n    nodes_boundary = list(nx.node_boundary(self.graph, self.old_nodes))\n\n    nodes_new = (\n        self.random.sample(self.old_nodes, k=(self.n_nodes - self.n_swaps)) + \n        self.random.sample(nodes_boundary, k=self.n_swaps)\n    )\n\n    self.subgraph = nx.subgraph(self.graph, nodes_new)\n</code></pre>"},{"location":"reference/mcmc/#minigraphs.mcmc.chains.SubgraphUniform","title":"<code>SubgraphUniform</code>","text":"<p>               Bases: <code>Chain</code></p> <p>Subgraphs are proposed by sampling uniformly from the original pool of nodes.</p> Source code in <code>src/minigraphs/mcmc/chains.py</code> <pre><code>class SubgraphUniform(Chain):\n    \"\"\"Subgraphs are proposed by sampling uniformly from the original pool of nodes.\n    \"\"\"\n    def __init__(self, graph, n_nodes, seed=None):\n        super().__init__(seed)\n        self.graph = graph\n        self.n_nodes = n_nodes\n\n        # Random subgraph\n        self.subgraph = nx.subgraph(graph, self.random.sample(list(graph.nodes), k=self.n_nodes))\n\n    def propose(self):\n        \"\"\"Proposes a uniform random subgraph\n        \"\"\"\n        self.old_nodes = [node for node in self.subgraph.nodes()]\n        self.subgraph = nx.subgraph(self.graph, self.random.sample(list(self.graph.nodes), k=self.n_nodes))\n\n    def reject(self):\n        self.subgraph = self.subgraph(self.graph, self.old_nodes)\n\n    @property \n    def state(self):\n        \"\"\"The currently sampled subgraph\n        \"\"\"\n        return self.subgraph\n</code></pre>"},{"location":"reference/mcmc/#minigraphs.mcmc.chains.SubgraphUniform-attributes","title":"Attributes","text":""},{"location":"reference/mcmc/#minigraphs.mcmc.chains.SubgraphUniform.state","title":"<code>state</code>  <code>property</code>","text":"<p>The currently sampled subgraph</p>"},{"location":"reference/mcmc/#minigraphs.mcmc.chains.SubgraphUniform-functions","title":"Functions","text":""},{"location":"reference/mcmc/#minigraphs.mcmc.chains.SubgraphUniform.propose","title":"<code>propose()</code>","text":"<p>Proposes a uniform random subgraph</p> Source code in <code>src/minigraphs/mcmc/chains.py</code> <pre><code>def propose(self):\n    \"\"\"Proposes a uniform random subgraph\n    \"\"\"\n    self.old_nodes = [node for node in self.subgraph.nodes()]\n    self.subgraph = nx.subgraph(self.graph, self.random.sample(list(self.graph.nodes), k=self.n_nodes))\n</code></pre>"},{"location":"reference/metrics/","title":"minigraphs.metrics","text":""},{"location":"reference/metrics/#minigraphs.metrics","title":"<code>minigraphs.metrics</code>","text":""},{"location":"reference/metrics/#minigraphs.metrics-functions","title":"Functions","text":""},{"location":"reference/metrics/#minigraphs.metrics.edge_cut_size","title":"<code>edge_cut_size(graph_full, sub_nodes)</code>","text":"<p>Number of edges with exactly one endpoint in the subgraph defined by <code>sub_nodes</code> and the other outside.</p> <p>Parameters:</p> <ul> <li> <code>graph_full</code>               (<code>Graph</code>)           \u2013            <p>The original large graph (needed to see external edges).</p> </li> <li> <code>sub_nodes</code>               (<code>Iterable</code>)           \u2013            <p>The node set of your miniature (can be a set, list, or view).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The size of the edge boundary of S.</p> </li> </ul> Source code in <code>src/minigraphs/metrics.py</code> <pre><code>def edge_cut_size(graph_full: nx.Graph, sub_nodes) -&gt; int:\n    \"\"\"\n    Number of edges with exactly one endpoint in the subgraph defined by `sub_nodes`\n    and the other outside.\n\n    Parameters\n    ----------\n    graph_full : nx.Graph\n        The original large graph (needed to see external edges).\n    sub_nodes : Iterable\n        The node set of your miniature (can be a set, list, or view).\n\n    Returns\n    -------\n    int\n        The size of the edge boundary of S.\n    \"\"\"\n    # edge_boundary returns an *iterator* of edges \u2192 just count them\n    return sum(1 for _ in edge_boundary(graph_full, sub_nodes))\n</code></pre>"},{"location":"reference/metrics/#minigraphs.metrics.graph_spectrum","title":"<code>graph_spectrum(graph, k=1)</code>","text":"<p>Calculates the <code>k</code> dominant eigenvalues of the adjacency matrix associated with the graph.</p> <p>Parameters:</p> <ul> <li> <code>graph</code>               (<code>Graph</code>)           \u2013            <p>Graph to calculate the spectrum.</p> </li> <li> <code>k</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The number of eigenvalues to calculate.</p> </li> </ul> Returns <p>List[float]     The <code>k</code> dominant eigenvalues of the adjacency matrix.</p> Source code in <code>src/minigraphs/metrics.py</code> <pre><code>def graph_spectrum(graph: nx.Graph, k: int=1) -&gt; List[float]:\n    \"\"\"Calculates the `k` dominant eigenvalues of the adjacency matrix associated with the graph.\n\n    Parameters\n    ----------\n    graph : nx.Graph\n        Graph to calculate the spectrum.\n    k : int, default=1\n        The number of eigenvalues to calculate. \n\n    Returns \n    -------\n    List[float]\n        The `k` dominant eigenvalues of the adjacency matrix.\n    \"\"\"\n    evals, _ = eigsh(nx.to_scipy_sparse_array(graph, dtype=np.float32), k=k, which='LM')\n\n    return list(evals)\n</code></pre>"},{"location":"reference/metrics/#minigraphs.metrics.laplacian_connectivity","title":"<code>laplacian_connectivity(G, normalized=False)</code>","text":"<p>Compute the algebraic connectivity \u03bb\u2082(L) of graph G.</p> <p>Parameters:</p> <ul> <li> <code>G</code>               (<code>Graph</code>)           \u2013            </li> <li> <code>normalized</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, uses the normalized Laplacian.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>\u03bb\u2082(L). Returns 0.0 for a graph with &lt;2 nodes.</p> </li> </ul> Source code in <code>src/minigraphs/metrics.py</code> <pre><code>def laplacian_connectivity(G: nx.Graph, normalized: bool = False) -&gt; float:\n    \"\"\"\n    Compute the algebraic connectivity \u03bb\u2082(L) of graph G.\n\n    Parameters\n    ----------\n    G : nx.Graph\n    normalized : bool\n        If True, uses the normalized Laplacian.\n\n    Returns\n    -------\n    float\n        \u03bb\u2082(L). Returns 0.0 for a graph with &lt;2 nodes.\n    \"\"\"\n    if G.number_of_nodes() &lt; 2:\n        return 0.0\n\n    return float(algebraic_connectivity(G, normalized=normalized))\n</code></pre>"},{"location":"reference/metrics/#minigraphs.metrics.spectral_radius","title":"<code>spectral_radius(graph)</code>","text":"<p>Calculates the spectral radius (dominant eigenvalue) of the adjacency matrix of a graph.</p> <p>Parameters:</p> <ul> <li> <code>graph</code>               (<code>Graph</code>)           \u2013            <p>Graph to calculate spectral radius.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The spectral radius of the graph.</p> </li> </ul> Source code in <code>src/minigraphs/metrics.py</code> <pre><code>def spectral_radius(graph: nx.Graph) -&gt; float:\n    \"\"\"Calculates the spectral radius (dominant eigenvalue) of the adjacency matrix of a graph.\n\n    Parameters\n    ----------\n    graph : nx.Graph\n        Graph to calculate spectral radius.\n\n    Returns\n    -------\n    float\n        The spectral radius of the graph.\n    \"\"\"\n    return graph_spectrum[0]\n</code></pre>"},{"location":"reference/reduction/","title":"minigraphs.reduction","text":""},{"location":"reference/reduction/#minigraphs.reduction","title":"<code>minigraphs.reduction</code>","text":""},{"location":"reference/reduction/#minigraphs.reduction-classes","title":"Classes","text":""},{"location":"reference/reduction/#minigraphs.reduction.CoarseNET","title":"<code>CoarseNET</code>","text":"<p>A class that implements the CoarseNET algorithm for an unweighted,  undirected graph.</p> <p>Parameters:</p> <ul> <li> <code>alpha</code>               (<code>float</code>)           \u2013            <p>Shrinkage factor.</p> </li> <li> <code>G</code>               (<code>Graph</code>)           \u2013            <p>Graph to coarsen.</p> </li> </ul> Source code in <code>src/minigraphs/reduction/coarsening.py</code> <pre><code>class CoarseNET:\n    '''\n    A class that implements the CoarseNET algorithm for an unweighted, \n    undirected graph.\n\n    Parameters\n    ----------\n    alpha : float\n        Shrinkage factor.\n\n    G : networkx.Graph\n        Graph to coarsen.\n    '''\n\n    def __init__(self,alpha: float,G: nx.Graph):\n        '''\n\n        '''\n        self.alpha = alpha\n        self.G = deepcopy(G)\n\n    @property\n    def alpha(self):\n        '''Shrinkage factor'''\n        return self._alpha\n\n    @alpha.setter\n    def alpha(self,val):\n        #TODO: Validate within range (0,1.0)\n        self._alpha = val\n\n    @property\n    def G(self):\n        '''Original Graph\n\n        Returns\n        -------\n        G : networkx.Graph\n            The original graph to miniaturize\n        '''\n        return self._G\n\n    @G.setter\n    def G(self,Graph: nx.Graph):\n        '''\n        Test\n        Parameters\n        ----------\n        Graph : networkx.Graph\n        '''\n        #TODO: Validate strongly connected graph\n        self._G = Graph\n\n    @staticmethod\n    def adjacency(G: nx.Graph):\n        '''Returns the column-normalized adjacency matrix of\n        a graph.\n\n        Parameters\n        ----------\n        G : networkx.Graph\n            A graph to construct the adjacency matrix.\n        '''\n        A = nx.to_scipy_sparse_array(G, dtype=np.float32)\n        A = normalize(A,norm='l2',axis=0)\n\n        return A\n\n    @staticmethod\n    def eigs(G: nx.Graph):\n        '''Computes the dominant eigenvalue and eigenvectors\n        associated with the adjacency matrix of a graph.\n\n        Parameters\n        ----------\n        G : networkx.Graph\n            Graph to calculate eigenvalue and eigenvectors.\n        '''\n        # Adjacency Matrix\n        A = CoarseNET.adjacency(G)\n\n        # Compute the first eigenvalue and right eigenvector\n        lambda_, u_ = scipy.sparse.linalg.eigs(A,k=1)\n\n        # Compute the left eigenvector\n        _, v_= scipy.sparse.linalg.eigs(A.T,k=1)\n\n        return np.real(lambda_)[0], np.real(np.squeeze(u_)), np.real(np.squeeze(v_))\n\n    def __edge_score(self, edge):\n        '''Calculates the score of a node pair\n        '''\n        u_a, u_b = self.u_[edge[0]], self.u_[edge[1]]\n        v_a, v_b = self.v_[edge[0]], self.v_[edge[1]]\n\n        prod = (self.lambda_-1)*(u_a+u_b)\n        score = (-self.lambda_*(u_a*v_a+u_b*v_b) + v_a*prod + u_a*v_b + u_b*v_a) / (np.dot(self.v_,self.u_)-(u_a*v_a + u_b*v_b))  \n\n        return score\n\n    def __score(self):\n        '''Calculates the score for all the edges in the graph\n        '''\n        # Initialize array of scores\n        score = np.zeros(self.G_coarse_.number_of_edges())\n\n        # Calculate score for every edge in the graph\n        for i, edge in enumerate(self.G_coarse_.edges):\n            score[i] = self.__edge_score(edge)\n\n        return np.abs(score)\n\n    def __contract(self,edge) -&gt; bool:\n        '''Updates graph by contracting nodes in the edge\n        '''\n        # Upack nodes\n        u, v = edge\n        left, right = self.nodes_coarse_[u], self.nodes_coarse_[v]\n\n        contract = left != right\n        if contract:\n            # Merge nodes\n            nx.contracted_nodes(self.G_coarse_,\n                                left,\n                                right,\n                                self_loops=False,\n                                copy=False)\n\n            # Update node index in coarsened graph\n            idx = self.nodes_coarse_ == right\n            self.nodes_coarse_[idx] = left \n            self.nodes_removed_.append(right)\n\n        return contract\n\n    def coarsen(self) -&gt; None:\n        '''\n        Coarsens the seed graph\n        '''\n        self.G_coarse_ = self._G.to_directed()\n        n = self.G_coarse_.number_of_nodes()\n        n_edges = self.G_coarse_.number_of_edges()\n        n_reduced = int(self._alpha * n)\n\n        # Compute the eigenvalue and eigenvectors\n        self.lambda_, self.u_, self.v_ = CoarseNET.eigs(self.G_coarse_)\n\n        # Arrays of nodes and edges\n        self.nodes_coarse_ = np.arange(0,n,dtype=np.int32)\n        self.nodes_removed_ = []\n        edges = list(self.G_coarse_.edges)\n\n        # Calculate sorting indices according to score\n        score = self.__score()\n        idx = np.argsort(score)\n\n        contractions = 0\n        i = 0\n        while (contractions &lt; n_reduced) and (i &lt; n_edges):\n            # Retrieve edge according to sorting\n            edge = edges[idx[i]]\n\n            # Contract edges\n            contract = self.__contract(edge)\n\n            if contract:\n                contractions += 1\n\n            i += 1\n</code></pre>"},{"location":"reference/reduction/#minigraphs.reduction.CoarseNET-attributes","title":"Attributes","text":""},{"location":"reference/reduction/#minigraphs.reduction.CoarseNET.G","title":"<code>G</code>  <code>property</code> <code>writable</code>","text":"<p>Original Graph</p> <p>Returns:</p> <ul> <li> <code>G</code> (              <code>Graph</code> )          \u2013            <p>The original graph to miniaturize</p> </li> </ul>"},{"location":"reference/reduction/#minigraphs.reduction.CoarseNET.alpha","title":"<code>alpha</code>  <code>property</code> <code>writable</code>","text":"<p>Shrinkage factor</p>"},{"location":"reference/reduction/#minigraphs.reduction.CoarseNET-functions","title":"Functions","text":""},{"location":"reference/reduction/#minigraphs.reduction.CoarseNET.__contract","title":"<code>__contract(edge)</code>","text":"<p>Updates graph by contracting nodes in the edge</p> Source code in <code>src/minigraphs/reduction/coarsening.py</code> <pre><code>def __contract(self,edge) -&gt; bool:\n    '''Updates graph by contracting nodes in the edge\n    '''\n    # Upack nodes\n    u, v = edge\n    left, right = self.nodes_coarse_[u], self.nodes_coarse_[v]\n\n    contract = left != right\n    if contract:\n        # Merge nodes\n        nx.contracted_nodes(self.G_coarse_,\n                            left,\n                            right,\n                            self_loops=False,\n                            copy=False)\n\n        # Update node index in coarsened graph\n        idx = self.nodes_coarse_ == right\n        self.nodes_coarse_[idx] = left \n        self.nodes_removed_.append(right)\n\n    return contract\n</code></pre>"},{"location":"reference/reduction/#minigraphs.reduction.CoarseNET.__edge_score","title":"<code>__edge_score(edge)</code>","text":"<p>Calculates the score of a node pair</p> Source code in <code>src/minigraphs/reduction/coarsening.py</code> <pre><code>def __edge_score(self, edge):\n    '''Calculates the score of a node pair\n    '''\n    u_a, u_b = self.u_[edge[0]], self.u_[edge[1]]\n    v_a, v_b = self.v_[edge[0]], self.v_[edge[1]]\n\n    prod = (self.lambda_-1)*(u_a+u_b)\n    score = (-self.lambda_*(u_a*v_a+u_b*v_b) + v_a*prod + u_a*v_b + u_b*v_a) / (np.dot(self.v_,self.u_)-(u_a*v_a + u_b*v_b))  \n\n    return score\n</code></pre>"},{"location":"reference/reduction/#minigraphs.reduction.CoarseNET.__init__","title":"<code>__init__(alpha, G)</code>","text":"Source code in <code>src/minigraphs/reduction/coarsening.py</code> <pre><code>def __init__(self,alpha: float,G: nx.Graph):\n    '''\n\n    '''\n    self.alpha = alpha\n    self.G = deepcopy(G)\n</code></pre>"},{"location":"reference/reduction/#minigraphs.reduction.CoarseNET.__score","title":"<code>__score()</code>","text":"<p>Calculates the score for all the edges in the graph</p> Source code in <code>src/minigraphs/reduction/coarsening.py</code> <pre><code>def __score(self):\n    '''Calculates the score for all the edges in the graph\n    '''\n    # Initialize array of scores\n    score = np.zeros(self.G_coarse_.number_of_edges())\n\n    # Calculate score for every edge in the graph\n    for i, edge in enumerate(self.G_coarse_.edges):\n        score[i] = self.__edge_score(edge)\n\n    return np.abs(score)\n</code></pre>"},{"location":"reference/reduction/#minigraphs.reduction.CoarseNET.adjacency","title":"<code>adjacency(G)</code>  <code>staticmethod</code>","text":"<p>Returns the column-normalized adjacency matrix of a graph.</p> <p>Parameters:</p> <ul> <li> <code>G</code>               (<code>Graph</code>)           \u2013            <p>A graph to construct the adjacency matrix.</p> </li> </ul> Source code in <code>src/minigraphs/reduction/coarsening.py</code> <pre><code>@staticmethod\ndef adjacency(G: nx.Graph):\n    '''Returns the column-normalized adjacency matrix of\n    a graph.\n\n    Parameters\n    ----------\n    G : networkx.Graph\n        A graph to construct the adjacency matrix.\n    '''\n    A = nx.to_scipy_sparse_array(G, dtype=np.float32)\n    A = normalize(A,norm='l2',axis=0)\n\n    return A\n</code></pre>"},{"location":"reference/reduction/#minigraphs.reduction.CoarseNET.coarsen","title":"<code>coarsen()</code>","text":"<p>Coarsens the seed graph</p> Source code in <code>src/minigraphs/reduction/coarsening.py</code> <pre><code>def coarsen(self) -&gt; None:\n    '''\n    Coarsens the seed graph\n    '''\n    self.G_coarse_ = self._G.to_directed()\n    n = self.G_coarse_.number_of_nodes()\n    n_edges = self.G_coarse_.number_of_edges()\n    n_reduced = int(self._alpha * n)\n\n    # Compute the eigenvalue and eigenvectors\n    self.lambda_, self.u_, self.v_ = CoarseNET.eigs(self.G_coarse_)\n\n    # Arrays of nodes and edges\n    self.nodes_coarse_ = np.arange(0,n,dtype=np.int32)\n    self.nodes_removed_ = []\n    edges = list(self.G_coarse_.edges)\n\n    # Calculate sorting indices according to score\n    score = self.__score()\n    idx = np.argsort(score)\n\n    contractions = 0\n    i = 0\n    while (contractions &lt; n_reduced) and (i &lt; n_edges):\n        # Retrieve edge according to sorting\n        edge = edges[idx[i]]\n\n        # Contract edges\n        contract = self.__contract(edge)\n\n        if contract:\n            contractions += 1\n\n        i += 1\n</code></pre>"},{"location":"reference/reduction/#minigraphs.reduction.CoarseNET.eigs","title":"<code>eigs(G)</code>  <code>staticmethod</code>","text":"<p>Computes the dominant eigenvalue and eigenvectors associated with the adjacency matrix of a graph.</p> <p>Parameters:</p> <ul> <li> <code>G</code>               (<code>Graph</code>)           \u2013            <p>Graph to calculate eigenvalue and eigenvectors.</p> </li> </ul> Source code in <code>src/minigraphs/reduction/coarsening.py</code> <pre><code>@staticmethod\ndef eigs(G: nx.Graph):\n    '''Computes the dominant eigenvalue and eigenvectors\n    associated with the adjacency matrix of a graph.\n\n    Parameters\n    ----------\n    G : networkx.Graph\n        Graph to calculate eigenvalue and eigenvectors.\n    '''\n    # Adjacency Matrix\n    A = CoarseNET.adjacency(G)\n\n    # Compute the first eigenvalue and right eigenvector\n    lambda_, u_ = scipy.sparse.linalg.eigs(A,k=1)\n\n    # Compute the left eigenvector\n    _, v_= scipy.sparse.linalg.eigs(A.T,k=1)\n\n    return np.real(lambda_)[0], np.real(np.squeeze(u_)), np.real(np.squeeze(v_))\n</code></pre>"},{"location":"reference/simulation/","title":"minigraphs.simulation","text":""},{"location":"reference/simulation/#minigraphs.simulation","title":"<code>minigraphs.simulation</code>","text":""},{"location":"reference/simulation/#minigraphs.simulation-classes","title":"Classes","text":""},{"location":"reference/simulation/#minigraphs.simulation.SIRModel","title":"<code>SIRModel</code>","text":"<p>               Bases: <code>Model</code></p> <p>Agent-based SIR model for the spread of disease.</p> <p>Parameters:</p> <ul> <li> <code>beta</code>               (<code>float</code>)           \u2013            <p>Infection probability over a link.</p> </li> <li> <code>gamma</code>               (<code>float</code>)           \u2013            <p>Recovery rate of an infected individual.</p> </li> <li> <code>network</code>               (<code>Graph</code>)           \u2013            <p>Underlying interaction network.</p> </li> <li> <code>n_infected</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Number of infected individuals at the beginning of the simulation.</p> </li> <li> <code>seed</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>Random state of the model</p> </li> </ul> Source code in <code>src/minigraphs/simulation/sir.py</code> <pre><code>class SIRModel(mesa.Model):\n    \"\"\"Agent-based SIR model for the spread of disease.\n\n    Parameters\n    ----------\n    beta: float\n        Infection probability over a link.\n    gamma: float\n        Recovery rate of an infected individual.\n    network: nx.Graph\n        Underlying interaction network.\n    n_infected: int\n        Number of infected individuals at the beginning of the simulation.\n    seed: float\n        Random state of the model\n    \"\"\"\n    def __init__(\n            self, \n            beta: float, \n            gamma: float, \n            network: Graph, \n            n_infected: int=1, \n            seed: int=None\n        ):\n        super().__init__(seed=seed)\n\n        self.n_agents = network.number_of_nodes()\n        self.beta = beta \n        self.gamma = gamma\n\n        # Initialize compartment count\n        self.compartment_count = dict.fromkeys([\"S\",\"I\",\"R\"], 0)\n        self.compartment_count[\"S\"] = self.n_agents - n_infected\n        self.compartment_count[\"I\"] = n_infected\n\n        # Create agents\n        compartments = [\"S\"] * (self.n_agents - n_infected) + [\"I\"] * n_infected\n        self.random.shuffle(compartments)\n\n        agents = IndividualAgent.create_agents(\n            self,\n            n=self.n_agents,\n            compartment=compartments,\n            node=list(range(self.n_agents))\n        )\n\n        # Create network and add agents to network\n        self.network = NetworkGrid(network)\n        for agent in agents: \n            self.network.place_agent(agent, agent.node)\n\n        self.datacollector = mesa.DataCollector(\n            model_reporters={\n                'S': lambda m: m.compartment_count['S'],\n                'I': lambda m: m.compartment_count['I'],\n                'R': lambda m: m.compartment_count['R'],\n            }\n        )\n\n    def step(self):\n        \"\"\"Advances the model one time step.\n        \"\"\" \n        self.datacollector.collect(self)\n        self.agents.do('compute_state') \n        self.agents.do('update_state')\n</code></pre>"},{"location":"reference/simulation/#minigraphs.simulation.SIRModel-functions","title":"Functions","text":""},{"location":"reference/simulation/#minigraphs.simulation.SIRModel.step","title":"<code>step()</code>","text":"<p>Advances the model one time step.</p> Source code in <code>src/minigraphs/simulation/sir.py</code> <pre><code>def step(self):\n    \"\"\"Advances the model one time step.\n    \"\"\" \n    self.datacollector.collect(self)\n    self.agents.do('compute_state') \n    self.agents.do('update_state')\n</code></pre>"}]}